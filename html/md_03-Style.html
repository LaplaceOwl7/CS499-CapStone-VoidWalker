<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CS499-Capstone: Style</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CS499-Capstone
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Style</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> Consistency is the most important aspect of style. The second most important aspect is following a style that the average C++ programmer is used to reading.</p>
<p>C++ allows for arbitrary-length identifier names, so there's no reason to be terse when naming things. Use descriptive names, and be consistent in the style.</p>
<ul>
<li><code>CamelCase</code></li>
<li><code>snake_case</code></li>
</ul>
<p>are common examples. <em>snake_case</em> has the advantage that it can also work with spell checkers, if desired.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Establishing A Style Guideline</h1>
<p>Whatever style guidelines you establish, be sure to implement a <code>.clang-format</code> file that specifies the style you expect. While this cannot help with naming, it is particularly important for an open source project to maintain a consistent style.</p>
<p>Every IDE and many editors have support for clang-format built in or easily installable with an add-in.</p>
<ul>
<li>VSCode: <a href="https://github.com/Microsoft/vscode-cpptools">Microsoft C/C++ extension for VS Code</a></li>
<li>CLion: <a href="https://www.jetbrains.com/help/clion/clangformat-as-alternative-formatter.html">https://www.jetbrains.com/help/clion/clangformat-as-alternative-formatter.html</a></li>
<li>VisualStudio <a href="https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.ClangFormat#review-details">https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.ClangFormat#review-details</a></li>
<li>Resharper++: <a href="https://www.jetbrains.com/help/resharper/2017.2/Using_Clang_Format.html">https://www.jetbrains.com/help/resharper/2017.2/Using_Clang_Format.html</a></li>
<li>Vim<ul>
<li><a href="https://github.com/rhysd/vim-clang-format">https://github.com/rhysd/vim-clang-format</a></li>
<li><a href="https://github.com/chiel92/vim-autoformat">https://github.com/chiel92/vim-autoformat</a></li>
</ul>
</li>
<li>XCode: <a href="https://github.com/travisjeffery/ClangFormat-Xcode">https://github.com/travisjeffery/ClangFormat-Xcode</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Common C++ Naming Conventions</h1>
<ul>
<li>Types start with upper case: <code>MyClass</code>.</li>
<li>Functions and variables start with lower case: <code>myMethod</code>.</li>
<li>Constants are all upper case: <code>const double PI=3.14159265358979323;</code>.</li>
</ul>
<p>C++ Standard Library (and other well-known C++ libraries like <a href="http://www.boost.org/">Boost</a>) use these guidelines:</p>
<ul>
<li>Macro names use upper case with underscores: <code>INT_MAX</code>.</li>
<li>Template parameter names use Pascal case: <code>InputIterator</code>.</li>
<li>All other names use snake case: <code>unordered_map</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Distinguish Private Object Data</h1>
<p>Name private data with a <code>m_</code> prefix to distinguish it from public data. <code>m_</code> stands for "member" data.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Distinguish Function Parameters</h1>
<p>The most important thing is consistency within your codebase; this is one possibility to help with consistency.</p>
<p>Name function parameters with an <code>t_</code> prefix. <code>t_</code> can be thought of as "the", but the meaning is arbitrary. The point is to distinguish function parameters from other variables in scope while giving us a consistent naming strategy.</p>
<p>Any prefix or postfix can be chosen for your organization. This is just one example. <em>This suggestion is controversial, for a discussion about it see issue <a href="https://github.com/lefticus/cppbestpractices/issues/11">#11</a>.</em></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Size</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> width;</div>
<div class="line">  <span class="keywordtype">int</span> height;</div>
<div class="line"> </div>
<div class="line">  Size(<span class="keywordtype">int</span> t_width, <span class="keywordtype">int</span> t_height) : width(t_width), height(t_height) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This version might make sense for thread safety or something,</span></div>
<div class="line"><span class="comment">// but more to the point, sometimes we need to hide data, sometimes we don&#39;t.</span></div>
<div class="line"><span class="keyword">class </span>PrivateSize</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">int</span> width()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_width; }</div>
<div class="line">    <span class="keywordtype">int</span> height()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_height; }</div>
<div class="line">    PrivateSize(<span class="keywordtype">int</span> t_width, <span class="keywordtype">int</span> t_height) : m_width(t_width), m_height(t_height) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">int</span> m_width;</div>
<div class="line">    <span class="keywordtype">int</span> m_height;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Don't Name Anything Starting With &lt;tt&gt;_&lt;/tt&gt;</h1>
<p>If you do, you risk colliding with names reserved for compiler and standard library implementation use:</p>
<p><a href="http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier">http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier</a></p>
<h1><a class="anchor" id="autotoc_md6"></a>
Well-Formed Example</h1>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyClass(<span class="keywordtype">int</span> t_data)</div>
<div class="line">    : m_data(t_data)</div>
<div class="line">  {</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> getData()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_data;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> m_data;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Enable Out-of-Source-Directory Builds</h1>
<p>Make sure generated files go into an output folder that is separate from the source folder.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Use &lt;tt&gt;nullptr&lt;/tt&gt;</h1>
<p>C++11 introduces <code>nullptr</code> which is a special value denoting a null pointer. This should be used instead of <code>0</code> or <code>NULL</code> to indicate a null pointer.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Comments</h1>
<p>Comment blocks should use <code>//</code>, not <code>/* */</code>. Using <code>//</code> makes it much easier to comment out a block of code while debugging.</p>
<div class="fragment"><div class="line"><span class="comment">// this function does something</span></div>
<div class="line"><span class="keywordtype">int</span> myFunc()</div>
<div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment --><p>To comment out this function block during debugging we might do:</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">// this function does something</span></div>
<div class="line"><span class="comment">int myFunc()</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">*/</span></div>
</div><!-- fragment --><p>which would be impossible if the function comment header used <code>/* */</code>.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Never Use &lt;tt&gt;using namespace&lt;/tt&gt; in a Header File</h1>
<p>This causes the namespace you are <code>using</code> to be pulled into the namespace of all files that include the header file. It pollutes the namespace and it may lead to name collisions in the future. Writing <code>using namespace</code> in an implementation file is fine though.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Include Guards</h1>
<p>Header files must contain a distinctly-named include guard to avoid problems with including the same header multiple times and to prevent conflicts with headers from other projects.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef MYPROJECT_MYCLASS_HPP</span></div>
<div class="line"><span class="preprocessor">#define MYPROJECT_MYCLASS_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>MyProject {</div>
<div class="line">  <span class="keyword">class </span>MyClass {</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>You may also consider using the <code>#pragma once</code> directive instead which is quasi-standard across many compilers. It's short and makes the intent clear.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
{} Are Required for Blocks.</h1>
<p>Leaving them off can lead to semantic errors in the code.</p>
<div class="fragment"><div class="line"><span class="comment">// Bad Idea</span></div>
<div class="line"><span class="comment">// This compiles and does what you want, but can lead to confusing</span></div>
<div class="line"><span class="comment">// errors if modification are made in the future and close attention</span></div>
<div class="line"><span class="comment">// is not paid.</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 15; ++i)</div>
<div class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad Idea</span></div>
<div class="line"><span class="comment">// The cout is not part of the loop in this case even though it appears to be.</span></div>
<div class="line"><span class="keywordtype">int</span> sum = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 15; ++i)</div>
<div class="line">  ++sum;</div>
<div class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Good Idea</span></div>
<div class="line"><span class="comment">// It&#39;s clear which statements are part of the loop (or if block, or whatever).</span></div>
<div class="line"><span class="keywordtype">int</span> sum = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 15; ++i) {</div>
<div class="line">  ++sum;</div>
<div class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Keep Lines a Reasonable Length</h1>
<div class="fragment"><div class="line"><span class="comment">// Bad Idea</span></div>
<div class="line"><span class="comment">// hard to follow</span></div>
<div class="line"><span class="keywordflow">if</span> (x &amp;&amp; y &amp;&amp; myFunctionThatReturnsBool() &amp;&amp; caseNumber3 &amp;&amp; (15 &gt; 12 || 2 &lt; 3)) {</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Good Idea</span></div>
<div class="line"><span class="comment">// Logical grouping, easier to read</span></div>
<div class="line"><span class="keywordflow">if</span> (x &amp;&amp; y &amp;&amp; myFunctionThatReturnsBool()</div>
<div class="line">    &amp;&amp; caseNumber3</div>
<div class="line">    &amp;&amp; (15 &gt; 12 || 2 &lt; 3)) {</div>
<div class="line">}</div>
</div><!-- fragment --><p>Many projects and coding standards have a soft guideline that one should try to use less than about 80 or 100 characters per line. Such code is generally easier to read. It also makes it possible to have two separate files next to each other on one screen without having a tiny font.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Use "" for Including Local Files</h1>
<p>... <code>&lt;&gt;</code> is <a href="http://blog2.emptycrate.com/content/when-use-include-verses-include">reserved for system includes</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Bad Idea. Requires extra -I directives to the compiler</span></div>
<div class="line"><span class="comment">// and goes against standards.</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;includes/MyHeader.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Worse Idea</span></div>
<div class="line"><span class="comment">// Requires potentially even more specific -I directives and</span></div>
<div class="line"><span class="comment">// makes code more difficult to package and distribute.</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;MyHeader.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Good Idea</span></div>
<div class="line"><span class="comment">// Requires no extra params and notifies the user that the file</span></div>
<div class="line"><span class="comment">// is a local file.</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;MyHeader.hpp&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md15"></a>
Initialize Member Variables</h1>
<p>...with the member initializer list.</p>
<p>For POD types, the performance of an initializer list is the same as manual initialization, but for other types there is a clear performance gain, see below.</p>
<div class="fragment"><div class="line"><span class="comment">// Bad Idea</span></div>
<div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyClass(<span class="keywordtype">int</span> t_value)</div>
<div class="line">  {</div>
<div class="line">    m_value = t_value;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> m_value;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad Idea</span></div>
<div class="line"><span class="comment">// This leads to an additional constructor call for m_myOtherClass</span></div>
<div class="line"><span class="comment">// before the assignment.</span></div>
<div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyClass(MyOtherClass t_myOtherClass)</div>
<div class="line">  {</div>
<div class="line">    m_myOtherClass = t_myOtherClass;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  MyOtherClass m_myOtherClass;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Good Idea</span></div>
<div class="line"><span class="comment">// There is no performance gain here but the code is cleaner.</span></div>
<div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyClass(<span class="keywordtype">int</span> t_value)</div>
<div class="line">    : m_value(t_value)</div>
<div class="line">  {</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> m_value;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Good Idea</span></div>
<div class="line"><span class="comment">// The default constructor for m_myOtherClass is never called here, so</span></div>
<div class="line"><span class="comment">// there is a performance gain if MyOtherClass is not is_trivially_default_constructible.</span></div>
<div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyClass(MyOtherClass t_myOtherClass)</div>
<div class="line">    : m_myOtherClass(t_myOtherClass)</div>
<div class="line">  {</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  MyOtherClass m_myOtherClass;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In C++11 you can assign default values to each member (using <code>=</code> or using <code>{}</code>).</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Assigning default values with =</h2>
<div class="fragment"><div class="line"><span class="comment">// ... //</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> m_value = 0; <span class="comment">// allowed</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> m_value_2 = -1; <span class="comment">// narrowing from signed to unsigned allowed</span></div>
<div class="line"><span class="comment">// ... //</span></div>
</div><!-- fragment --><p> This ensures that no constructor ever "forgets" to initialize a member object.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Assigning default values with brace initialization</h2>
<p>Using brace initialization does not allow narrowing at compile-time.</p>
<div class="fragment"><div class="line"><span class="comment">// Best Idea</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... //</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> m_value{ 0 }; <span class="comment">// allowed</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> m_value_2 { -1 }; <span class="comment">// narrowing from signed to unsigned not allowed, leads to a compile time error</span></div>
<div class="line"><span class="comment">// ... //</span></div>
</div><!-- fragment --><p>Prefer <code>{}</code> initialization over <code>=</code> unless you have a strong reason not to.</p>
<p>Forgetting to initialize a member is a source of undefined behavior bugs which are often extremely hard to find.</p>
<p>If the member variable is not expected to change after the initialization, then mark it <code>const</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyClass(<span class="keywordtype">int</span> t_value)</div>
<div class="line">    : m_value{t_value}</div>
<div class="line">  {</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> m_value{0};</div>
<div class="line">};</div>
</div><!-- fragment --><p>Since a const member variable cannot be assigned a new value, such a class may not have a meaningful copy assignment operator.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Always Use Namespaces</h1>
<p>There is almost never a reason to declare an identifier in the global namespace. Instead, functions and classes should exist in an appropriately named namespace or in a class inside of a namespace. Identifiers which are placed in the global namespace risk conflicting with identifiers from other libraries (mostly <a class="el" href="classC.html">C</a>, which doesn't have namespaces).</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Use the Correct Integer Type for Standard Library Features</h1>
<p>The standard library generally uses <code>std::size_t</code> for anything related to size. The size of <code>size_t</code> is implementation defined.</p>
<p>In general, using <code>auto</code> will avoid most of these issues, but not all.</p>
<p>Make sure you stick with the correct integer types and remain consistent with the C++ standard library. It might not warn on the platform you are currently using, but it probably will when you change platforms.</p>
<p><em>Note that you can cause integer underflow when performing some operations on unsigned values. For example:</em></p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v1{2,3,4,5,6,7,8,9};</div>
<div class="line">std::vector&lt;int&gt; v2{9,8,7,6,5,4,3,2,1};</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s1 = v1.size();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s2 = v2.size();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> diff = s1 - s2; <span class="comment">// diff underflows to a very large number</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md20"></a>
Use .hpp and .cpp for Your File Extensions</h1>
<p>Ultimately this is a matter of preference, but .hpp and .cpp are widely recognized by various editors and tools. So the choice is pragmatic. Specifically, Visual Studio only automatically recognizes .cpp and .cxx for C++ files, and Vim doesn't necessarily recognize .cc as a C++ file.</p>
<p>One particularly large project (<a href="https://github.com/NREL/OpenStudio">OpenStudio</a>) uses .hpp and .cpp for user-generated files and .hxx and .cxx for tool-generated files. Both are well recognized and having the distinction is helpful.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Never Mix Tabs and Spaces</h1>
<p>Some editors like to indent with a mixture of tabs and spaces by default. This makes the code unreadable to anyone not using the exact same tab indentation settings. Configure your editor so this does not happen.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Never Put Code with Side Effects Inside an assert()</h1>
<div class="fragment"><div class="line">assert(registerSomeThing()); <span class="comment">// make sure that registerSomeThing() returns true</span></div>
</div><!-- fragment --><p>The above code succeeds when making a debug build, but gets removed by the compiler when making a release build, giving you different behavior between debug and release builds. This is because <code>assert()</code> is a macro which expands to nothing in release mode.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Don't Be Afraid of Templates</h1>
<p>They can help you stick to <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY principles</a>. They should be preferred to macros, because macros do not honor namespaces, etc.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Use Operator Overloads Judiciously</h1>
<p>Operator overloading was invented to enable expressive syntax. Expressive in the sense that adding two big integers looks like <code>a + b</code> and not <code>a.add(b)</code>. Another common example is <code>std::string</code>, where it is very common to concatenate two strings with <code>string1 + string2</code>.</p>
<p>However, you can easily create unreadable expressions using too much or wrong operator overloading. When overloading operators, there are three basic rules to follow as described <a href="http://stackoverflow.com/questions/4421706/operator-overloading/4421708#4421708">on stackoverflow</a>.</p>
<p>Specifically, you should keep these things in mind:</p>
<ul>
<li>Overloading <code>operator=()</code> when handling resources is a must. See <a href="03-Style.md#consider-the-rule-of-zero">Consider the Rule of Zero</a> below.</li>
<li>For all other operators, only overload them when they are used in a context that is commonly connected to these operators. Typical scenarios are concatenating things with +, negating expressions that can be considered "true" or "false", etc.</li>
<li>Always be aware of the <a href="http://en.cppreference.com/w/cpp/language/operator_precedence">operator precedence</a> and try to circumvent unintuitive constructs.</li>
<li>Do not overload exotic operators such as ~ or % unless implementing a numeric type or following a well recognized syntax in specific domain.</li>
<li><a href="http://stackoverflow.com/questions/5602112/when-to-overload-the-comma-operator?answertab=votes#tab-top">Never</a> overload <code>operator,()</code> (the comma operator).</li>
<li>Use non-member functions <code>operator&gt;&gt;()</code> and <code>operator&lt;&lt;()</code> when dealing with streams. For example, you can overload <code>operator&lt;&lt;(std::ostream &amp;, MyClass const &amp;)</code> to enable "writing" your class into a stream, such as <code>std::cout</code> or an <code>std::fstream</code> or <code>std::stringstream</code>. The latter is often used to create a string representation of a value.</li>
<li>There are more common operators to overload <a href="http://stackoverflow.com/questions/4421706/operator-overloading?answertab=votes#tab-top">described here</a>.</li>
</ul>
<p>More tips regarding the implementation details of your custom operators can be found <a href="http://courses.cms.caltech.edu/cs11/material/cpp/donnie/cpp-ops.html">here</a>.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Avoid Implicit Conversions</h1>
<h2><a class="anchor" id="autotoc_md26"></a>
Single Parameter Constructors</h2>
<p>Single parameter constructors can be applied at compile time to automatically convert between types. This is handy for things like <code>std::string(const char *)</code> but should be avoided in general because they can add to accidental runtime overhead.</p>
<p>Instead mark single parameter constructors as <code>explicit</code>, which requires them to be explicitly called.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Conversion Operators</h2>
<p>Similarly to single parameter constructors, conversion operators can be called by the compiler and introduce unexpected overhead. They should also be marked as <code>explicit</code>.</p>
<div class="fragment"><div class="line"><span class="comment">//bad idea</span></div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  <span class="keyword">operator</span> int() {</div>
<div class="line">    <span class="keywordflow">return</span> 2;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">//good idea</span></div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  <span class="keyword">explicit</span> <span class="keyword">operator</span> int() {</div>
<div class="line">    <span class="keywordflow">return</span> 2;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md28"></a>
Consider the Rule of Zero</h1>
<p>The Rule of Zero states that you do not provide any of the functions that the compiler can provide (copy constructor, copy assignment operator, move constructor, move assignment operator, destructor) unless the class you are constructing does some novel form of ownership.</p>
<p>The goal is to let the compiler provide optimal versions that are automatically maintained when more member variables are added.</p>
<p><a href="http://www.nirfriedman.com/2015/06/27/cpp-rule-of-zero/">This article</a> provides a background and explains techniques for implementing nearly 100% of the time. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
